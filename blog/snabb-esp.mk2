In November 2016 we landed an implementation of RFC 4303 “IP Encapsulating
Security Payload” and RFC 4106 “The Use of Galois/Counter Mode (GCM) in IPsec
Encapsulating Security Payload (ESP)” along with optimized reference AES
routines from Intel for use with [Snabb NFV](https://github.com/snabbco/snabb#snabbnfv)
upstream. In this article we want to document the development process that
spawned [lib.ipsec](http://snabbco.github.io/#ipsec), some technical decisions
we made, and implementation details that we find noteworthy.

XXX - introduction

< Technology stack

 Characteristic of this implementation is that its written in a highly dynamic
 [LuaJIT](http://luajit.org/) world, while other IPsec implementations are
 usually written in and surrounded by C or C++.

 #media#
 snabb-esp-languages.svg

 XXX - LuaJIT FFI

>

< Re-use: Intel’s reference AES GCM implementation

 [http://www.intel.com/content/dam/www/public/us/en/documents/white-papers/fast-multi-buffer-ipsec-implementations-ia-processors-paper.pdf]

 XXX - Intel AES to DynASM

 #code C interface of Intel’s AES GCM reference implementation, including some
 helpful comments from the original source.#
 void aesni_gcm_dec_avx_gen4
 (gcm_data      *my_ctx_data,   /* aligned to 16 Bytes */
  uint8_t       *out,           /* Plaintext output. Decrypt in-place is
                                   allowed. */
  const uint8_t *in,            /* Ciphertext input */
  uint64_t       plaintext_len, /* Length of data in Bytes for encryption. */
  uint8_t       *iv,            /* Pre-counter block j0: 4 byte salt (from
                                   Security Association) concatenated with 8
                                   byte Initialisation Vector (from IPSec ESP
                                   Payload) concatenated with 0x00000001.
                                   16-byte aligned pointer. */
  const uint8_t *aad,           /* Additional Authentication Data (AAD)*/
  uint64_t       aad_len,       /* Length of AAD in bytes. With RFC4106 this
                                   is going to be 8 or 12 Bytes */
  uint8_t       *auth_tag,      /* Authenticated Tag output. */
  uint64_t       auth_tag_len); /* Authenticated Tag Length in bytes. Valid
                                   values are 16 (most likely), 12 or 8. */
 #

>

< Sequence numbers

>

< Replay protection

>

< Resynchronization

>

< Testing

 XXX - profile

 XXX - Snabb NFV CI

 XXX - Linux interop testing using Nix

>
